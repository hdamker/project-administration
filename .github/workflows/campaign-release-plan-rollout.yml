# =========================================================================================
# CAMARA Project - Campaign: Release Plan Rollout
#
# Adds release-plan.yaml to all CAMARA API repositories based on data from
# releases-master.yaml. Creates PRs for repositories that don't yet have the file.
#
# PREREQUISITES:
# - Secret BULK_CAMPAIGN_TOKEN: Fine-grained PAT with the following permissions:
#   - Contents: Read and write (create branches, commit changes)
#   - Pull requests: Read and write (create PRs in target repos)
#
# DOCUMENTATION:
# https://github.com/camaraproject/project-administration/blob/main/campaigns/release-plan-rollout/docs/README.md
# =========================================================================================

name: Campaign - Release Plan Rollout

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (plan only, no PRs created)'
        required: true
        type: boolean
        default: true
      include:
        description: 'Comma-separated list of repository names to process (e.g., "QualityOnDemand, DeviceLocation"). Empty = all repos.'
        required: false
        type: string
        default: ''
      include_wip_repos:
        description: 'Include repositories without release but with API definition files (work in progress, require manual review)'
        required: false
        type: boolean
        default: true
      include_new_repos:
        description: 'Include repositories without API definition files and releases (new repositories)'
        required: false
        type: boolean
        default: false

concurrency:
  group: campaign-release-plan-rollout-${{ github.ref }}
  cancel-in-progress: false

env:
  MODE: ${{ inputs.dry_run && 'plan' || 'apply' }}
  ORG: camaraproject
  RELEASES_FILE: data/releases-master.yaml
  INCLUDE: ${{ inputs.include }}
  INCLUDE_WIP_REPOS: ${{ inputs.include_wip_repos }}
  INCLUDE_NEW_REPOS: ${{ inputs.include_new_repos }}
  BRANCH: bulk/release-plan-rollout-${{ github.run_id }}
  PR_TITLE: "[bulk] Add release-plan.yaml"

permissions:
  contents: write
  pull-requests: write

jobs:
  select:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.sel.outputs.repos }}
    steps:
      - name: Checkout admin repo (self)
        uses: actions/checkout@v4
        with:
          path: admin

      - name: Install js-yaml
        run: npm install js-yaml

      - id: sel
        name: Build repo list (from repositories array + include filter + skip existing)
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.BULK_CAMPAIGN_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const { execSync } = require('child_process');

            // Load releases-master.yaml
            const doc = yaml.load(fs.readFileSync('admin/data/releases-master.yaml', 'utf8'));

            // Get all repos from repositories array with release info
            let list = (doc?.repositories || []).map(r => ({
              slug: `${process.env.ORG}/${r.repository}`,
              name: r.repository,
              hasRelease: !!(r.latest_public_release || r.newest_pre_release),
              releaseTag: r.newest_pre_release || r.latest_public_release || null,
              hasApiFiles: null  // Will be detected for repos without releases
            }));

            // Apply include filter if specified
            const include = (process.env.INCLUDE||'').split(',').map(s=>s.trim()).filter(Boolean);
            if (include.length) {
              list = list.filter(r => include.some(x => r.slug.endsWith(`/${x}`)));
              console.log(`Include filter applied: ${include.join(', ')}`);
            }

            console.log(`Found ${list.length} repositories after filtering`);

            // For repos without releases, check if they have API files
            const reposWithoutRelease = list.filter(r => !r.hasRelease);
            console.log(`\nChecking ${reposWithoutRelease.length} repositories without releases for API files...`);

            for (const repo of reposWithoutRelease) {
              try {
                const result = execSync(
                  `gh api repos/${repo.slug}/contents/code/API_definitions --jq 'length' 2>/dev/null || echo "0"`,
                  { encoding: 'utf8' }
                ).trim();
                repo.hasApiFiles = parseInt(result) > 0;
                console.log(`  ${repo.name}: ${repo.hasApiFiles ? 'Has API files' : 'No API files'}`);
              } catch (e) {
                repo.hasApiFiles = false;
                console.log(`  ${repo.name}: Could not check (${e.message})`);
              }
            }

            // Categorize and filter based on inputs
            const includeWip = process.env.INCLUDE_WIP_REPOS === 'true';
            const includeNew = process.env.INCLUDE_NEW_REPOS === 'true';

            console.log(`\nInput settings: include_wip_repos=${includeWip}, include_new_repos=${includeNew}`);

            const counts = { withRelease: 0, wip: 0, new: 0, skippedWip: 0, skippedNew: 0, skippedExists: 0 };
            const filteredList = [];

            for (const repo of list) {
              // Determine category
              let category;
              if (repo.hasRelease) {
                category = 'with_release';
              } else if (repo.hasApiFiles) {
                category = 'wip';
              } else {
                category = 'new';
              }

              // Check if category is included
              if (category === 'wip' && !includeWip) {
                counts.skippedWip++;
                console.log(`⊘ ${repo.name}: Skipping (WIP repo, include_wip_repos=false)`);
                continue;
              }
              if (category === 'new' && !includeNew) {
                counts.skippedNew++;
                console.log(`⊘ ${repo.name}: Skipping (new repo, include_new_repos=false)`);
                continue;
              }

              // Check if release-plan.yaml already exists
              try {
                const result = execSync(
                  `gh api repos/${repo.slug}/contents/release-plan.yaml --jq '.name' 2>/dev/null || echo "NOT_FOUND"`,
                  { encoding: 'utf8' }
                ).trim();

                if (result !== 'NOT_FOUND' && result !== '') {
                  counts.skippedExists++;
                  console.log(`⊘ ${repo.name}: Skipping (release-plan.yaml already exists)`);
                  continue;
                }
              } catch (e) {
                // If API call fails, include the repo
              }

              // Add to final list
              filteredList.push(repo.slug);
              counts[category === 'with_release' ? 'withRelease' : category]++;
              console.log(`✓ ${repo.name}: Will process (category: ${category})`);
            }

            console.log(`\n=== Summary ===`);
            console.log(`Repositories to process: ${filteredList.length}`);
            console.log(`  - With releases: ${counts.withRelease}`);
            console.log(`  - Work in progress: ${counts.wip}`);
            console.log(`  - New repos: ${counts.new}`);
            console.log(`Skipped:`);
            console.log(`  - Already have release-plan.yaml: ${counts.skippedExists}`);
            console.log(`  - WIP repos excluded: ${counts.skippedWip}`);
            console.log(`  - New repos excluded: ${counts.skippedNew}`);

            core.setOutput('repos', JSON.stringify(filteredList));

  run:
    needs: select
    if: ${{ needs.select.outputs.repos != '[]' }}
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ env.MODE }}
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.select.outputs.repos) }}

    steps:
      - name: Checkout admin repo (self)
        uses: actions/checkout@v4
        with:
          path: admin

      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: repo
          fetch-depth: 0
          token: ${{ secrets.BULK_CAMPAIGN_TOKEN }}

      - name: Install dependencies
        run: npm install js-yaml mustache

      - name: Generate release-plan.yaml
        id: generate
        uses: ./admin/campaigns/release-plan-rollout/actions/generate-release-plan
        with:
          releases_file: admin/${{ env.RELEASES_FILE }}
          repo_slug: ${{ matrix.repo }}
          out_file: repo/release-plan.yaml

      - name: Render PR body
        id: pr_body
        uses: ./admin/actions/render-mustache
        with:
          template: admin/campaigns/release-plan-rollout/templates/pr-body.mustache
          data_json: ${{ steps.generate.outputs.json }}
          out_file: /tmp/pr-body.md

      # Note: Validation step will be added when tooling shared-action is ready
      # - name: Validate generated release-plan.yaml
      #   id: validate
      #   uses: camaraproject/tooling/shared-actions/validate-release-plan@v0
      #   with:
      #     metadata_file: repo/release-plan.yaml
      #     type: release-plan

      - name: Detect changes
        id: changes
        shell: bash
        working-directory: repo
        run: |
          if [ -f "release-plan.yaml" ]; then
            git add release-plan.yaml
            if git diff --cached --quiet; then
              echo "changed=false" >> $GITHUB_OUTPUT
            else
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "::warning::release-plan.yaml was not generated"
          fi

      - name: Campaign finalize
        uses: ./admin/actions/campaign-finalize-per-repo
        with:
          mode: ${{ env.MODE }}
          changed: ${{ steps.changes.outputs.changed }}
          repo: ${{ matrix.repo }}
          campaign_data: ${{ steps.generate.outputs.json }}
          pr_base_title: ${{ env.PR_TITLE }}
          pr_body_file: /tmp/pr-body.md
          branch: ${{ env.BRANCH }}
          github_token: ${{ secrets.BULK_CAMPAIGN_TOKEN }}
          target_files: release-plan.yaml

  aggregate:
    needs: [select, run]
    if: ${{ always() && inputs.dry_run && needs.select.outputs.repos != '[]' }}
    runs-on: ubuntu-latest
    steps:
      - name: Download all plan artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: plan-*
          merge-multiple: true
          path: plans

      - name: Merge plan files
        run: |
          echo "# Release Plan Rollout Campaign - Plan Summary" > plan.md
          echo "" >> plan.md
          echo "Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> plan.md
          echo "Mode: plan (dry run)" >> plan.md
          echo "Settings: include_wip_repos=${{ inputs.include_wip_repos }}, include_new_repos=${{ inputs.include_new_repos }}" >> plan.md
          echo "" >> plan.md

          if [ -d plans ]; then
            for f in plans/*.md; do
              [ -f "$f" ] && cat "$f" >> plan.md && echo "" >> plan.md
            done

            # Merge JSONL files
            cat plans/*.jsonl > plan.jsonl 2>/dev/null || true
          fi

          echo "## Summary" >> plan.md
          echo "" >> plan.md

          TOTAL=$(wc -l < plan.jsonl 2>/dev/null | tr -d ' ' || echo 0)
          echo "**Total repositories processed:** ${TOTAL}" >> plan.md
          echo "" >> plan.md

          if [ -f plan.jsonl ] && [ -s plan.jsonl ]; then
            # Count repos with releases (no warning field)
            WITH_RELEASE=$(grep -c '"warning":' plan.jsonl 2>/dev/null && echo "" || echo "")
            WITH_RELEASE_COUNT=$((TOTAL - $(grep -c '"warning"' plan.jsonl 2>/dev/null || echo 0)))
            WITHOUT_RELEASE_COUNT=$(grep -c '"warning"' plan.jsonl 2>/dev/null || echo 0)

            echo "**Category breakdown:**" >> plan.md
            echo "- With releases: ${WITH_RELEASE_COUNT}" >> plan.md
            echo "- Without releases (placeholders): ${WITHOUT_RELEASE_COUNT}" >> plan.md
          fi

      - name: Upload merged plan
        uses: actions/upload-artifact@v4
        with:
          name: campaign-plan
          path: |
            plan.md
            plan.jsonl

      - name: Add workflow summary
        run: |
          echo "## Release Plan Rollout Campaign - Plan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat plan.md >> $GITHUB_STEP_SUMMARY
