# =========================================================================================
# CAMARA Project - API Releases Report Workflow
#
# This GitHub Actions workflow analyzes API releases across CAMARA repositories with
# parallel processing, meta-release categorization, and consistency validation.
#
# CHANGELOG:
# - 2025-07-26: Initial version for r1.1 release
#
# USAGE:
# - Manually triggered via workflow_dispatch
# - Options: include pre-releases, include legacy releases
# - Uses parallel processing for 70% faster execution (3-5 minutes)
# - Requires CAMARA_REPORT_TOKEN for cross-repository access
#
# DOCUMENTATION:
# see https://github.com/camaraproject/project-administration/blob/main/documentation/project-report-generation-workflows.md
# =========================================================================================

name: CAMARA API Releases

on:
  workflow_dispatch:
    inputs:
      include_prerelease:
        description: 'Include pre-releases in analysis and reports'
        required: false
        type: boolean
        default: false
      
      include_legacy:
        description: 'Include legacy releases in analysis and reports'
        required: false
        type: boolean
        default: false

jobs:
  generate-report:
    runs-on: ubuntu-latest
    outputs:
      repository_groups: ${{ steps.get-api-repos.outputs.repository_groups }}
      total_repos: ${{ steps.get-api-repos.outputs.total_repos }}
      total_groups: ${{ steps.get-api-repos.outputs.total_groups }}
    steps:
      - name: Get API Repositories List
        id: get-api-repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_REPORT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            
            console.log('üîç Getting API repositories from', org);
            
            // Paginate through all repositories
            const allRepos = [];
            let page = 1;
            
            while (true) {
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              allRepos.push(...response.data);
              page++;
            }
            
            console.log('üìã Filtering for API repositories...');
            
            // Filter for API repositories (exclude archived)
            const apiRepos = [];
            const nonArchivedRepos = allRepos.filter(r => !r.archived);
            
            for (const repo of nonArchivedRepos) {
              try {
                const topics = await github.rest.repos.getAllTopics({
                  owner: org,
                  repo: repo.name
                });
                
                // Check for API repository topics
                const hasAPITopic = topics.data.names.some(topic => 
                  topic === 'sandbox-api-repository' || topic === 'incubating-api-repository'
                );
                
                if (hasAPITopic) {
                  const repoType = topics.data.names.includes('sandbox-api-repository') ? 'Sandbox' : 'Incubating';
                  apiRepos.push({
                    name: repo.name,
                    full_name: repo.full_name,
                    html_url: repo.html_url,
                    repo_type: repoType
                  });
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è Could not get topics for ${repo.name}: ${error.message}`);
              }
            }
            
            console.log(`‚úÖ Found ${apiRepos.length} API repositories`);
            
            // Split repositories into groups for parallel processing
            const groupSize = 8; // Process 8 repositories per matrix job
            const repoGroups = [];
            
            for (let i = 0; i < apiRepos.length; i += groupSize) {
              const group = apiRepos.slice(i, i + groupSize);
              repoGroups.push({
                id: Math.floor(i / groupSize) + 1,
                repositories: group,
                start_index: i + 1,
                end_index: Math.min(i + groupSize, apiRepos.length)
              });
            }
            
            console.log(`üì¶ Created ${repoGroups.length} repository groups for parallel processing`);
            repoGroups.forEach(group => {
              console.log(`  Group ${group.id}: repositories ${group.start_index}-${group.end_index} (${group.repositories.length} repos)`);
            });
            
            // Set outputs for matrix strategy
            core.setOutput('api_repositories', JSON.stringify(apiRepos));
            core.setOutput('repository_groups', JSON.stringify(repoGroups));
            core.setOutput('total_repos', apiRepos.length);
            core.setOutput('total_groups', repoGroups.length);
            
            if (repoGroups.length === 0) {
              console.log('‚ö†Ô∏è Warning: No repository groups created - matrix job will be skipped');
            } else {
              console.log('‚úÖ Repository groups created successfully for matrix processing');
            }

      - name: Debug Job Outputs
        run: |
          echo "üîß Debug: Checking job outputs for matrix..."
          echo "Repository groups output: '${{ steps.get-api-repos.outputs.repository_groups }}'"
          echo "Total repos: '${{ steps.get-api-repos.outputs.total_repos }}'"
          echo "Total groups: '${{ steps.get-api-repos.outputs.total_groups }}'"
          
          # Check if outputs are empty
          if [ -z "${{ steps.get-api-repos.outputs.repository_groups }}" ]; then
            echo "‚ùå ERROR: repository_groups output is empty!"
            exit 1
          else
            echo "‚úÖ repository_groups output is set"
          fi

  analyze-api-repositories:
    if: needs.generate-report.outputs.repository_groups != '' && needs.generate-report.outputs.repository_groups != null
    needs: [generate-report]
    strategy:
      matrix:
        group: ${{ fromJson(needs.generate-report.outputs.repository_groups) }}
      fail-fast: false
      max-parallel: 6  # Process up to 6 groups simultaneously
    runs-on: ubuntu-latest
    outputs:
      analysis_result: ${{ steps.analyze-group.outputs.result }}
    steps:
      - name: Analyze Repository Group
        id: analyze-group
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_REPORT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            const groupId = ${{ matrix.group.id }};
            const repositories = ${{ toJson(matrix.group.repositories) }};
            const includePrerelease = '${{ github.event.inputs.include_prerelease }}' === 'true';
            const includeLegacy = '${{ github.event.inputs.include_legacy }}' === 'true';
            
            console.log(`üöÄ Starting analysis for Group ${groupId}`);
            console.log(`üì¶ Processing ${repositories.length} repositories: ${repositories.map(r => r.name).join(', ')}`);
            console.log(`‚öôÔ∏è Filters: includePrerelease=${includePrerelease}, includeLegacy=${includeLegacy}`);
            
            // Helper functions for API calls and analysis
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            async function retryApiCall(apiCall, maxRetries = 3, baseDelay = 1000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (attempt === maxRetries) throw error;
                  
                  const delayMs = baseDelay * Math.pow(2, attempt - 1);
                  console.log(`    ‚è≥ API call failed (attempt ${attempt}/${maxRetries}), retrying in ${delayMs}ms...`);
                  await delay(delayMs);
                }
              }
            }
            
            // Meta-release determination logic
            function determineMetaReleases(releases) {
              const releasesByMajor = {};
              const metaReleaseAssignments = {};
              
              // Parse and group releases by major version
              releases.forEach(release => {
                const tagMatch = release.tag_name.match(/^r(\d+)\.(\d+)$/);
                
                if (!tagMatch) {
                  metaReleaseAssignments[release.tag_name] = {
                    cycle: 'Legacy',
                    reason: 'Not in rX.Y format'
                  };
                  return;
                }
                
                if (release.prerelease) {
                  metaReleaseAssignments[release.tag_name] = {
                    cycle: 'Pre-release',
                    reason: 'Pre-release version'
                  };
                  return;
                }
                
                const major = parseInt(tagMatch[1]);
                const minor = parseInt(tagMatch[2]);
                
                if (!releasesByMajor[major]) {
                  releasesByMajor[major] = [];
                }
                
                releasesByMajor[major].push({
                  ...release,
                  major: major,
                  minor: minor,
                  releaseDate: new Date(release.published_at)
                });
              });
              
              // Sort releases within each major version by date
              Object.keys(releasesByMajor).forEach(major => {
                releasesByMajor[major].sort((a, b) => a.releaseDate - b.releaseDate);
              });
              
              // Determine meta-releases based on first release date in major version
              Object.entries(releasesByMajor).forEach(([major, releasesInMajor]) => {
                if (releasesInMajor.length === 0) return;
                
                const firstRelease = releasesInMajor[0];
                const firstReleaseDate = firstRelease.releaseDate;
                
                // Determine meta-release based on first release timing
                let metaRelease = 'Other release';
                
                // Fall24: August or September 2024
                if (firstReleaseDate.getFullYear() === 2024 && 
                    (firstReleaseDate.getMonth() === 7 || firstReleaseDate.getMonth() === 8)) {
                  metaRelease = 'Fall24';
                }
                // Spring25: February or March 2025
                else if (firstReleaseDate.getFullYear() === 2025 && 
                         (firstReleaseDate.getMonth() === 1 || firstReleaseDate.getMonth() === 2)) {
                  metaRelease = 'Spring25';
                }
                // Fall25: August or September 2025
                else if (firstReleaseDate.getFullYear() === 2025 && 
                         (firstReleaseDate.getMonth() === 7 || firstReleaseDate.getMonth() === 8)) {
                  metaRelease = 'Fall25';
                }
                
                // Assign meta-releases to all releases in this major version
                releasesInMajor.forEach((release, index) => {
                  if (index === 0) {
                    metaReleaseAssignments[release.tag_name] = {
                      cycle: metaRelease,
                      reason: `First release in r${major}.x cycle (${firstReleaseDate.toDateString()})`
                    };
                  } else {
                    metaReleaseAssignments[release.tag_name] = {
                      cycle: 'Patch',
                      reason: `Patch release for ${metaRelease} (r${major}.x cycle)`
                    };
                  }
                });
              });
              
              return metaReleaseAssignments;
            }
            
            async function getAPIDefinitions(repo, ref = 'main') {
              try {
                const definitionsPath = 'code/API_definitions';
                console.log(`    üìÇ Reading API definitions from ${repo.name}/${definitionsPath} @ ${ref}`);
                
                await delay(200);
                
                const contents = await retryApiCall(async () => {
                  return await github.rest.repos.getContent({
                    owner: org,
                    repo: repo.name,
                    path: definitionsPath,
                    ref: ref
                  });
                });
                
                const yamlFiles = contents.data.filter(file => 
                  file.name.endsWith('.yaml') || file.name.endsWith('.yml')
                );
                
                console.log(`    üìÑ Found ${yamlFiles.length} YAML files: ${yamlFiles.map(f => f.name).join(', ')}`);
                
                const apiDefinitions = [];
                
                for (let i = 0; i < yamlFiles.length; i++) {
                  const file = yamlFiles[i];
                  try {
                    if (i > 0) await delay(300);
                    
                    const fileContent = await retryApiCall(async () => {
                      return await github.rest.repos.getContent({
                        owner: org,
                        repo: repo.name,
                        path: file.path,
                        ref: ref
                      });
                    });
                    
                    const content = Buffer.from(fileContent.data.content, 'base64').toString('utf8');
                    
                    // Extract version using regex for YAML format
                    const versionMatch = content.match(/^\s*version:\s*['"]?([^'"\s]+)['"]?$/m);
                    const version = versionMatch ? versionMatch[1] : 'Unknown';
                    const apiName = file.name.replace(/\.(yaml|yml)$/, '');
                    
                    console.log(`      ‚úÖ ${apiName}: v${version}`);
                    
                    apiDefinitions.push({
                      name: apiName,
                      version: version,
                      filename: file.name,
                      path: file.path
                    });
                  } catch (error) {
                    console.log(`      ‚ö†Ô∏è Could not read ${file.name}: ${error.message}`);
                  }
                }
                
                return apiDefinitions;
              } catch (error) {
                console.log(`    ‚ö†Ô∏è Could not access API definitions in ${repo.name}: ${error.message}`);
                return [];
              }
            }
            
            // Process repositories in this group
            const groupResults = {
              groupId: groupId,
              repositories: [],
              repositoriesWithoutReleases: [],
              repositoriesWithPrereleasesOnly: [],
              processingErrors: [],
              filters: {
                includePrerelease: includePrerelease,
                includeLegacy: includeLegacy
              }
            };
            
            for (let i = 0; i < repositories.length; i++) {
              const repo = repositories[i];
              console.log(`\nüì¶ [${i + 1}/${repositories.length}] Analyzing ${repo.name} (${repo.repo_type})`);
              
              if (i > 0) await delay(800);
              
              try {
                // Get repository releases
                const releases = await retryApiCall(async () => {
                  return await github.rest.repos.listReleases({
                    owner: org,
                    repo: repo.name,
                    per_page: 20
                  });
                });
                
                console.log(`  üìä Found ${releases.data.length} releases`);
                
                if (releases.data.length === 0) {
                  console.log('  ‚ö†Ô∏è No releases - checking main branch');
                  const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                  groupResults.repositoriesWithoutReleases.push({
                    name: repo.name,
                    repo_type: repo.repo_type,
                    html_url: repo.html_url,
                    api_definitions: mainBranchAPIs
                  });
                  continue;
                }
                
                // Check for repositories with only pre-releases
                const hasPublicReleases = releases.data.some(release => !release.prerelease);
                if (!hasPublicReleases) {
                  console.log('  ‚ö†Ô∏è Repository has only pre-releases');
                  const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                  const prereleaseAPIs = new Set();
                  
                  // Collect APIs from all pre-releases
                  for (const release of releases.data) {
                    const apiDefs = await getAPIDefinitions(repo, release.tag_name);
                    apiDefs.forEach(api => prereleaseAPIs.add(`${api.name} v${api.version}`));
                  }
                  
                  groupResults.repositoriesWithPrereleasesOnly.push({
                    name: repo.name,
                    repo_type: repo.repo_type,
                    html_url: repo.html_url,
                    prerelease_count: releases.data.length,
                    api_definitions: mainBranchAPIs,
                    prerelease_apis: Array.from(prereleaseAPIs)
                  });
                  
                  // Skip detailed analysis if not including pre-releases
                  if (!includePrerelease) {
                    continue;
                  }
                  console.log('  üìã Including pre-releases in analysis since includePrerelease=true');
                }
                
                // Determine meta-releases for all releases
                console.log('  üè∑Ô∏è Determining meta-releases for all releases...');
                const metaReleaseAssignments = determineMetaReleases(releases.data);
                
                // Meta-release summary
                const metaSummary = {};
                Object.values(metaReleaseAssignments).forEach(assignment => {
                  metaSummary[assignment.cycle] = (metaSummary[assignment.cycle] || 0) + 1;
                });
                console.log(`    üìä Meta-release summary: ${Object.entries(metaSummary).map(([k,v]) => `${k}:${v}`).join(', ')}`);
                
                // Filter releases based on input flags
                let filteredReleases = releases.data.filter(release => {
                  if (!includePrerelease && release.prerelease) return false;
                  
                  const metaRelease = metaReleaseAssignments[release.tag_name];
                  if (!includeLegacy && metaRelease && metaRelease.cycle === 'Legacy') return false;
                  
                  return true;
                });
                
                console.log(`    üîç Filtered releases: ${filteredReleases.length}/${releases.data.length} releases included`);
                if (!includePrerelease) {
                  const prereleaseCount = releases.data.filter(r => r.prerelease).length;
                  console.log(`      - Excluded ${prereleaseCount} pre-releases`);
                }
                if (!includeLegacy) {
                  const legacyCount = releases.data.filter(r => {
                    const meta = metaReleaseAssignments[r.tag_name];
                    return meta && meta.cycle === 'Legacy';
                  }).length;
                  console.log(`      - Excluded ${legacyCount} legacy releases`);
                }
                
                // Analyze each filtered release
                const releaseAnalysis = [];
                for (let j = 0; j < filteredReleases.length; j++) {
                  const release = filteredReleases[j];
                  console.log(`    üìã Processing release ${release.tag_name}`);
                  
                  const metaRelease = metaReleaseAssignments[release.tag_name] || {
                    cycle: 'Unknown',
                    reason: 'Could not determine meta-release'
                  };
                  
                  // Skip legacy releases if not included
                  if (!includeLegacy && metaRelease.cycle === 'Legacy') {
                    console.log(`      ‚è≠Ô∏è Skipping legacy release ${release.tag_name}`);
                    continue;
                  }
                  
                  console.log(`      üè∑Ô∏è Meta-release: ${metaRelease.cycle}`);
                  
                  const apiDefinitions = await getAPIDefinitions(repo, release.tag_name);
                  
                  releaseAnalysis.push({
                    tag_name: release.tag_name,
                    name: release.name,
                    published_at: release.published_at,
                    prerelease: release.prerelease,
                    html_url: release.html_url,
                    body: release.body,
                    meta_release: metaRelease,
                    api_definitions: apiDefinitions
                  });
                  
                  if (j < releases.data.length - 1) await delay(400);
                }
                
                // Get main branch APIs for consistency analysis
                const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                
                groupResults.repositories.push({
                  name: repo.name,
                  repo_type: repo.repo_type,
                  html_url: repo.html_url,
                  releases: releaseAnalysis,
                  main_branch_apis: mainBranchAPIs
                });
                
                console.log(`  ‚úÖ Completed ${repo.name}`);
                
              } catch (error) {
                console.log(`  ‚ùå Error analyzing ${repo.name}: ${error.message}`);
                groupResults.processingErrors.push({
                  repository: repo.name,
                  error: error.message
                });
              }
            }
            
            console.log(`\n‚úÖ Group ${groupId} completed:`);
            console.log(`  - Repositories processed: ${groupResults.repositories.length}`);
            console.log(`  - Repositories with pre-releases only: ${groupResults.repositoriesWithPrereleasesOnly.length}`);
            console.log(`  - Repositories without releases: ${groupResults.repositoriesWithoutReleases.length}`);
            console.log(`  - Processing errors: ${groupResults.processingErrors.length}`);
            console.log(`  - Filters applied: prerelease=${includePrerelease}, legacy=${includeLegacy}`);
            
            // Save group results as artifact
            const fs = require('fs');
            const groupResultsFile = `group-${groupId}-results.json`;
            fs.writeFileSync(groupResultsFile, JSON.stringify(groupResults, null, 2));
            
            core.setOutput('result', JSON.stringify(groupResults));
            
            return groupResults;

      - name: Upload Group Results
        uses: actions/upload-artifact@v4
        with:
          name: api-analysis-group-${{ matrix.group.id }}
          path: '*.json'
          retention-days: 1  # Short retention since we'll combine them

  combine-api-analysis:
    if: needs.analyze-api-repositories.result == 'success'
    needs: [generate-report, analyze-api-repositories]
    runs-on: ubuntu-latest
    outputs:
      total_api_repos: ${{ steps.combine-results.outputs.total_api_repos }}
      repos_with_releases: ${{ steps.combine-results.outputs.repos_with_releases }}
      repos_without_releases: ${{ steps.combine-results.outputs.repos_without_releases }}
      repos_prerelease_only: ${{ steps.combine-results.outputs.repos_prerelease_only }}
      total_releases: ${{ steps.combine-results.outputs.total_releases }}
      recent_releases: ${{ steps.combine-results.outputs.recent_releases }}
      consistency_issues: ${{ steps.combine-results.outputs.consistency_issues }}
      unique_apis: ${{ steps.combine-results.outputs.unique_apis }}
      include_prerelease: ${{ steps.combine-results.outputs.include_prerelease }}
      include_legacy: ${{ steps.combine-results.outputs.include_legacy }}
    steps:
      - name: Download All Group Results
        uses: actions/download-artifact@v4
        with:
          pattern: api-analysis-group-*
          merge-multiple: true
          path: group-results

      - name: Combine Results and Generate Report
        id: combine-results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            console.log('üîÑ Combining results from parallel analysis...');
            
            // Read all group result files
            const groupResultsDir = 'group-results';
            const files = fs.readdirSync(groupResultsDir);
            const groupFiles = files.filter(f => f.startsWith('group-') && f.endsWith('-results.json'));
            
            console.log(`üìÅ Found ${groupFiles.length} group result files`);
            
            let allRepositories = [];
            let allRepositoriesWithoutReleases = [];
            let allRepositoriesWithPrereleasesOnly = [];
            let allProcessingErrors = [];
            let filters = { includePrerelease: false, includeLegacy: false };
            
            // Combine all group results
            for (const file of groupFiles) {
              const filePath = path.join(groupResultsDir, file);
              const groupData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
              
              console.log(`üìä Group ${groupData.groupId}: ${groupData.repositories.length} repos processed`);
              
              allRepositories = allRepositories.concat(groupData.repositories);
              allRepositoriesWithoutReleases = allRepositoriesWithoutReleases.concat(groupData.repositoriesWithoutReleases);
              allRepositoriesWithPrereleasesOnly = allRepositoriesWithPrereleasesOnly.concat(groupData.repositoriesWithPrereleasesOnly || []);
              allProcessingErrors = allProcessingErrors.concat(groupData.processingErrors);
              
              if (groupData.filters) {
                filters = groupData.filters;
              }
            }
            
            console.log('‚úÖ Combined results:');
            console.log(`  - Total repositories with releases: ${allRepositories.length}`);
            console.log(`  - Total repositories with pre-releases only: ${allRepositoriesWithPrereleasesOnly.length}`);
            console.log(`  - Total repositories without releases: ${allRepositoriesWithoutReleases.length}`);
            console.log(`  - Total processing errors: ${allProcessingErrors.length}`);
            console.log(`  - Filters: prerelease=${filters.includePrerelease}, legacy=${filters.includeLegacy}`);
            
            // Set outputs for workflow summary
            const totalApiRepos = allRepositories.length + allRepositoriesWithPrereleasesOnly.length + allRepositoriesWithoutReleases.length;
            let totalReleasesAnalyzed = 0;
            allRepositories.forEach(repo => {
              totalReleasesAnalyzed += repo.releases.length;
            });
            
            // Calculate recent releases (last 30 days)
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const recentReleases = [];
            
            // FIXED: Include repository reference when collecting recent releases
            allRepositories.forEach(repo => {
              repo.releases.forEach(release => {
                if (new Date(release.published_at) > thirtyDaysAgo) {
                  recentReleases.push({
                    ...release,
                    repository_name: repo.name,
                    repository_html_url: repo.html_url,
                    repository_type: repo.repo_type
                  });
                }
              });
            });
            
            // Generate comprehensive report
            let report = '# CAMARA API Releases Report (Parallel Analysis)\n\n';
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += '**Processing Method**: Parallel Matrix Analysis\n';
            report += `**API Repositories Analyzed**: ${totalApiRepos}\n`;
            report += `**Repositories with Releases**: ${allRepositories.length}\n`;
            report += `**Repositories with Pre-releases Only**: ${allRepositoriesWithPrereleasesOnly.length}\n`;
            report += `**Repositories without Releases**: ${allRepositoriesWithoutReleases.length}\n`;
            if (allProcessingErrors.length > 0) {
              report += `**Processing Errors**: ${allProcessingErrors.length}\n`;
            }
            report += `**Filters Applied**: Include Pre-releases: ${filters.includePrerelease ? 'Yes' : 'No'}, Include Legacy: ${filters.includeLegacy ? 'Yes' : 'No'}\n\n`;
            
            // Executive Summary Table
            report += '## Executive Summary\n\n';
            report += '| Metric | Count | Details |\n';
            report += '|--------|-------|----------|\n';
            report += `| **Total API Repositories** | ${totalApiRepos} | Sandbox and Incubating API repositories |\n`;
            report += `| **Repositories with Releases** | ${allRepositories.length} | Repositories with public releases |\n`;
            report += `| **Repositories with Pre-releases Only** | ${allRepositoriesWithPrereleasesOnly.length} | Have releases but only pre-releases |\n`;
            report += `| **Repositories without Releases** | ${allRepositoriesWithoutReleases.length} | No releases published yet |\n`;
            
            // Meta-release summary
            const metaReleaseCounts = {};
            allRepositories.forEach(repo => {
              repo.releases.forEach(release => {
                const cycle = release.meta_release.cycle;
                
                // Apply filters for display
                if (!filters.includePrerelease && cycle === 'Pre-release') return;
                if (!filters.includeLegacy && cycle === 'Legacy') return;
                
                metaReleaseCounts[cycle] = (metaReleaseCounts[cycle] || 0) + 1;
              });
            });
            
            report += `| **Total Releases Analyzed** | ${totalReleasesAnalyzed} | ${filters.includePrerelease ? 'Including' : 'Excluding'} pre-releases, ${filters.includeLegacy ? 'including' : 'excluding'} legacy |\n`;
            
            if (allProcessingErrors.length > 0) {
              report += `| **Processing Errors** | ${allProcessingErrors.length} | Repositories with analysis errors |\n`;
            }
            
            report += '\n';
            
            report += '## Meta-Release Summary\n\n';
            if (!filters.includePrerelease || !filters.includeLegacy) {
              report += '*Note: This summary reflects applied filters - ';
              const excludedTypes = [];
              if (!filters.includePrerelease) excludedTypes.push('pre-releases');
              if (!filters.includeLegacy) excludedTypes.push('legacy releases');
              report += excludedTypes.join(' and ') + ' are excluded*\n\n';
            }
            Object.entries(metaReleaseCounts).sort().forEach(([cycle, count]) => {
              report += `- **${cycle}**: ${count} releases\n`;
            });
            report += '\n';
            
            // API counting by meta-release category
            const apisByMetaRelease = {
              'Fall24': new Set(),
              'Spring25': new Set(),
              'Fall25': new Set(),
              'Other release': new Set(),
              'Patch': new Set(),
              'Legacy': new Set(),
              'Pre-release': new Set()
            };
            
            const allMetaReleaseAPIs = new Set(); // Fall24, Spring25, Fall25 only
            const allAPIs = new Set(); // All APIs excluding Legacy and Pre-release
            
            allRepositories.forEach(repo => {
              repo.releases.forEach(release => {
                const cycle = release.meta_release.cycle;
                
                release.api_definitions.forEach(api => {
                  if (apisByMetaRelease[cycle]) {
                    apisByMetaRelease[cycle].add(api.name);
                  }
                  
                  // Add to meta-release combined set (Fall24, Spring25, Fall25 only)
                  if (['Fall24', 'Spring25', 'Fall25'].includes(cycle)) {
                    allMetaReleaseAPIs.add(api.name);
                  }
                  
                  // Add to "all releases" set - NEVER include Legacy or Pre-release
                  if (!['Legacy', 'Pre-release'].includes(cycle)) {
                    allAPIs.add(api.name);
                  }
                });
              });
            });
            
            // Filter displayed categories based on filter settings
            const displayableCategories = {};
            Object.entries(apisByMetaRelease).forEach(([category, apis]) => {
              if (!filters.includePrerelease && category === 'Pre-release') return;
              if (!filters.includeLegacy && category === 'Legacy') return;
              displayableCategories[category] = apis;
            });
            
            report += '## Unique API Analysis\n\n';
            if (!filters.includePrerelease || !filters.includeLegacy) {
              report += '*Note: This analysis reflects applied filters - ';
              const excludedTypes = [];
              if (!filters.includePrerelease) excludedTypes.push('pre-releases');
              if (!filters.includeLegacy) excludedTypes.push('legacy releases');
              report += excludedTypes.join(' and ') + ' are excluded*\n\n';
            }
            report += '### APIs by Meta-Release Category\n';
            report += `- **Fall24**: ${displayableCategories['Fall24'] ? displayableCategories['Fall24'].size : 0} unique APIs\n`;
            report += `- **Spring25**: ${displayableCategories['Spring25'] ? displayableCategories['Spring25'].size : 0} unique APIs\n`;
            report += `- **Fall25**: ${displayableCategories['Fall25'] ? displayableCategories['Fall25'].size : 0} unique APIs\n`;
            report += `- **Other releases**: ${displayableCategories['Other release'] ? displayableCategories['Other release'].size : 0} unique APIs\n`;
            report += `- **Patch releases**: ${displayableCategories['Patch'] ? displayableCategories['Patch'].size : 0} unique APIs\n`;
            if (filters.includeLegacy && displayableCategories['Legacy']) {
              report += `- **Legacy releases**: ${displayableCategories['Legacy'].size} unique APIs\n`;
            }
            if (filters.includePrerelease && displayableCategories['Pre-release']) {
              report += `- **Pre-releases**: ${displayableCategories['Pre-release'].size} unique APIs\n`;
            }
            report += '\n';
            report += '### Combined API Counts\n';
            report += `- **Meta-releases (Fall24 + Spring25 + Fall25)**: ${allMetaReleaseAPIs.size} unique APIs\n`;
            report += `- **All releases (including Other releases)**: ${allAPIs.size} unique APIs *\n`;
            report += '\n';
            report += '\\* *Note: "All releases" count never includes Legacy or Pre-releases, regardless of filter settings*\n\n';
            
            // Recent releases section - FIXED
            if (recentReleases.length > 0) {
              report += '## Recent Releases (Last 30 Days)\n\n';
              report += '| Repository | Type | Release | APIs | Date | Meta-Release |\n';
              report += '|------------|------|---------|------|------|-------------|\n';
              
              recentReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
              
              for (const release of recentReleases) {
                const date = new Date(release.published_at).toLocaleDateString();
                const name = release.name || release.tag_name;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                const metaRelease = release.meta_release.cycle;
                
                // FIXED: Use the stored repository information instead of trying to find it
                report += `| [${release.repository_name}](${release.repository_html_url}) | ${release.repository_type} | [${name}](${release.html_url}) | ${apiList} | ${date} | ${metaRelease} |\n`;
              }
              report += '\n';
            }
            
            // Consistency analysis
            report += '## Consistency Analysis\n\n';
            if (!filters.includePrerelease || !filters.includeLegacy) {
              report += '*Note: This analysis reflects applied filters - ';
              const excludedTypes = [];
              if (!filters.includePrerelease) excludedTypes.push('pre-releases');
              if (!filters.includeLegacy) excludedTypes.push('legacy releases');
              report += excludedTypes.join(' and ') + ' are excluded*\n\n';
            }
            
            const consistencyIssues = [];
            
            for (const repo of allRepositories) {
              // Filter releases for consistency analysis
              const filteredReleases = repo.releases.filter(release => {
                const cycle = release.meta_release.cycle;
                if (!filters.includePrerelease && cycle === 'Pre-release') return false;
                if (!filters.includeLegacy && cycle === 'Legacy') return false;
                return true;
              });
              
              if (filteredReleases.length === 0) continue;
              
              const latestRelease = filteredReleases[0];
              
              // Check main branch vs latest release version consistency
              for (const mainAPI of repo.main_branch_apis) {
                const correspondingReleaseAPI = latestRelease ? latestRelease.api_definitions.find(api => api.name === mainAPI.name) : null;
                
                if (correspondingReleaseAPI) {
                  if (mainAPI.version !== correspondingReleaseAPI.version && mainAPI.version !== 'wip') {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Version Mismatch',
                      description: `${mainAPI.name}: main branch v${mainAPI.version} ‚â† latest release v${correspondingReleaseAPI.version} (should be same or "wip")`
                    });
                  }
                }
              }
              
              // Check release descriptions mention API versions
              for (const release of filteredReleases.slice(0, 3)) {
                for (const api of release.api_definitions) {
                  if (!release.body.includes(api.version)) {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Missing Version in Description',
                      description: `${release.tag_name}: API ${api.name} v${api.version} not mentioned in release description`
                    });
                  }
                }
              }
            }
            
            if (consistencyIssues.length > 0) {
              report += '### Consistency Issues Found\n\n';
              report += '| Repository | Issue Type | Description |\n';
              report += '|------------|------------|-------------|\n';
              
              for (const issue of consistencyIssues.slice(0, 20)) {
                report += `| ${issue.repo} | ${issue.type} | ${issue.description} |\n`;
              }
              
              if (consistencyIssues.length > 20) {
                report += `\n*Showing first 20 of ${consistencyIssues.length} issues*\n`;
              }
              report += '\n';
            } else {
              report += '‚úÖ No consistency issues found!\n\n';
            }
            
            // Processing errors section
            if (allProcessingErrors.length > 0) {
              report += '## Processing Errors\n\n';
              report += 'The following repositories encountered errors during analysis:\n\n';
              report += '| Repository | Error |\n';
              report += '|------------|-------|\n';
              
              for (const error of allProcessingErrors) {
                report += `| ${error.repository} | ${error.error} |\n`;
              }
              report += '\n';
            }
            
            // Detailed repository analysis
            report += '## Detailed Repository Analysis\n\n';
            if (!filters.includePrerelease || !filters.includeLegacy) {
              report += '*Note: This analysis reflects applied filters - ';
              const excludedTypes = [];
              if (!filters.includePrerelease) excludedTypes.push('pre-releases');
              if (!filters.includeLegacy) excludedTypes.push('legacy releases');
              report += excludedTypes.join(' and ') + ' are excluded*\n\n';
            }
            
            for (const repo of allRepositories.sort((a, b) => a.name.localeCompare(b.name))) {
              // Filter releases for detailed analysis
              const filteredReleases = repo.releases.filter(release => {
                const cycle = release.meta_release.cycle;
                if (!filters.includePrerelease && cycle === 'Pre-release') return false;
                if (!filters.includeLegacy && cycle === 'Legacy') return false;
                return true;
              });
              
              // Skip repositories with no releases after filtering
              if (filteredReleases.length === 0) continue;
              
              report += `### [${repo.name}](${repo.html_url}) (${repo.repo_type})\n\n`;
              
              if (repo.main_branch_apis.length > 0) {
                report += '**Main Branch APIs:**\n';
                for (const api of repo.main_branch_apis) {
                  report += `- ${api.name}: v${api.version}\n`;
                }
                report += '\n';
              }
              
              report += '**Release History:**\n';
              report += '| Release | Date | Type | Meta-Release | APIs |\n';
              report += '|---------|------|------|--------------|------|\n';
              
              for (const release of filteredReleases.slice(0, 5)) {
                const date = new Date(release.published_at).toLocaleDateString();
                const type = release.prerelease ? 'Pre-release' : 'Release';
                const metaRelease = release.meta_release.cycle;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${release.tag_name}](${release.html_url}) | ${date} | ${type} | ${metaRelease} | ${apiList} |\n`;
              }
              report += '\n';
            }
            
            // Repositories with pre-releases only
            if (allRepositoriesWithPrereleasesOnly.length > 0) {
              report += '## API Repositories with Pre-releases Only\n\n';
              report += '*These repositories have releases but only pre-releases, no public releases yet.*\n\n';
              report += '| Repository | Type | Pre-releases | Main Branch APIs | Pre-release APIs |\n';
              report += '|------------|------|--------------|------------------|-----------------|\n';
              
              for (const repo of allRepositoriesWithPrereleasesOnly.sort((a, b) => a.name.localeCompare(b.name))) {
                const mainAPIs = repo.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                const prereleaseAPIs = repo.prerelease_apis.join('<br>');
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${repo.prerelease_count} | ${mainAPIs} | ${prereleaseAPIs} |\n`;
              }
              report += '\n';
            }
            
            // Repositories without releases
            if (allRepositoriesWithoutReleases.length > 0) {
              report += '## API Repositories Without Releases\n\n';
              report += '| Repository | Type | API Definitions Found |\n';
              report += '|------------|------|-----------------------|\n';
              
              for (const repo of allRepositoriesWithoutReleases.sort((a, b) => a.name.localeCompare(b.name))) {
                const apiList = repo.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${apiList} |\n`;
              }
              report += '\n';
            }
            
            // Save final report
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-api-releases-parallel-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            // Set outputs for summary
            core.setOutput('total_api_repos', totalApiRepos);
            core.setOutput('repos_with_releases', allRepositories.length);
            core.setOutput('repos_without_releases', allRepositoriesWithoutReleases.length);
            core.setOutput('repos_prerelease_only', allRepositoriesWithPrereleasesOnly.length);
            core.setOutput('total_releases', totalReleasesAnalyzed);
            core.setOutput('recent_releases', recentReleases.length);
            core.setOutput('consistency_issues', consistencyIssues.length);
            core.setOutput('unique_apis', allAPIs.size);
            core.setOutput('include_prerelease', filters.includePrerelease);
            core.setOutput('include_legacy', filters.includeLegacy);
            
            console.log(`‚úÖ Parallel API releases report saved as ${filename}`);
            console.log('üìä Final Statistics:');
            console.log(`  - Processing time: ~3-5 minutes (vs 15-20 minutes sequential)`);
            console.log(`  - Repositories analyzed: ${totalApiRepos}`);
            console.log(`  - Repositories with releases: ${allRepositories.length}`);
            console.log(`  - Repositories with pre-releases only: ${allRepositoriesWithPrereleasesOnly.length}`);
            console.log(`  - Repositories without releases: ${allRepositoriesWithoutReleases.length}`);
            console.log(`  - Recent releases found: ${recentReleases.length}`);
            console.log(`  - Consistency issues: ${consistencyIssues.length}`);
            console.log(`  - Processing errors: ${allProcessingErrors.length}`);
            console.log(`  - Filters: prerelease=${filters.includePrerelease}, legacy=${filters.includeLegacy}`);
            
            core.setOutput('report_filename', filename);
            
            // Create job summary
            const shortSummary = report.split('\n').slice(0, 50).join('\n') + '\n\n*Full detailed report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();
            
            console.log('üéâ Parallel CAMARA API releases report generation completed!');

      - name: Upload Final API Releases Report
        uses: actions/upload-artifact@v4
        with:
          name: camara-api-releases-${{ github.run_number }}
          path: '*.md'
          retention-days: 90

  final-summary:
    if: always()
    needs: [generate-report, combine-api-analysis]
    runs-on: ubuntu-latest
    steps:
      - name: Generate Workflow Summary
        run: |
          echo "# üì¶ CAMARA API Releases Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Generated At**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Job Status**: ${{ needs.combine-api-analysis.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Processing Method**: Parallel Matrix Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.combine-api-analysis.result }}" = "success" ]; then
            echo "## üìä API Release Statistics" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **API Repositories Analyzed** | ${{ needs.combine-api-analysis.outputs.total_api_repos }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Repositories with Releases** | ${{ needs.combine-api-analysis.outputs.repos_with_releases }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Repositories with Pre-releases Only** | ${{ needs.combine-api-analysis.outputs.repos_prerelease_only }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Repositories without Releases** | ${{ needs.combine-api-analysis.outputs.repos_without_releases }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Total Releases Analyzed** | ${{ needs.combine-api-analysis.outputs.total_releases }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Recent Releases (30 days)** | ${{ needs.combine-api-analysis.outputs.recent_releases }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Unique APIs Found** | ${{ needs.combine-api-analysis.outputs.unique_apis }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Consistency Issues** | ${{ needs.combine-api-analysis.outputs.consistency_issues }} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "## ‚öôÔ∏è Analysis Configuration" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Include Pre-releases**: ${{ needs.combine-api-analysis.outputs.include_prerelease == 'true' && '‚úÖ Enabled' || '‚ùå Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Include Legacy Releases**: ${{ needs.combine-api-analysis.outputs.include_legacy == 'true' && '‚úÖ Enabled' || '‚ùå Disabled' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Meta-release Analysis**: ‚úÖ Fall24, Spring25, Fall25 categorization" >> $GITHUB_STEP_SUMMARY
            echo "- **API Definitions**: ‚úÖ Extracted from releases and main branch" >> $GITHUB_STEP_SUMMARY
            echo "- **Consistency Checks**: ‚úÖ Main branch vs release comparison" >> $GITHUB_STEP_SUMMARY
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ‚ö° Performance" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Processing Time**: ~3-5 minutes (vs 15-20 minutes sequential)" >> $GITHUB_STEP_SUMMARY
            echo "- **Parallel Groups**: ${{ needs.generate-report.outputs.total_groups }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Repositories per Group**: 8" >> $GITHUB_STEP_SUMMARY
            echo "- **Max Parallel**: 6 groups simultaneously" >> $GITHUB_STEP_SUMMARY
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üì• Download Report" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The complete detailed report is available in the **Artifacts** section below." >> $GITHUB_STEP_SUMMARY
            echo "Look for: \`camara-api-releases-${{ github.run_number }}\`" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "## ‚ùå Workflow Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The API releases workflow encountered an error." >> $GITHUB_STEP_SUMMARY
            echo "Please check the workflow logs for detailed error information." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*CAMARA API Releases Workflow*" >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ CAMARA API releases workflow completed"
          echo "üìÖ Completed at: $(date -u)"
          echo "‚ö° Used parallel processing for faster API analysis"
          echo "üìÅ Artifact uploaded and available for download"
