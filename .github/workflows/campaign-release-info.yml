# =========================================================================================
# CAMARA Project - Campaign: Release Info Sync
#
# Synchronizes Release Information sections in API repository READMEs based on data
# from releases-master.yaml. Creates PRs to update release tables across repositories.
#
# PREREQUISITES:
# - Secret BULK_CAMPAIGN_TOKEN: Fine-grained PAT with the following permissions:
#   - Contents: Read and write (create branches, commit changes)
#   - Pull requests: Read and write (create PRs in target repos)
#
# CHANGELOG:
# - 2024-12-17: Standardized header format
#
# DOCUMENTATION:
# https://github.com/camaraproject/project-administration/blob/main/campaigns/release-info/docs/README.md
# =========================================================================================

name: Campaign - Release Info Sync

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (plan only, no PRs created)'
        required: true
        type: boolean
        default: true
      include:
        description: 'Comma-separated list of repository names to process (e.g., "QualityOnDemand, DeviceLocation"). Empty = all repos matching enabled categories.'
        required: false
        type: string
        default: ''
      include_no_release:
        description: 'Include repositories with no releases'
        required: false
        type: boolean
        default: false
      include_prerelease_only:
        description: 'Include repositories with only pre-releases'
        required: false
        type: boolean
        default: false
      include_public_release:
        description: 'Include repositories with public releases (no newer pre-release)'
        required: false
        type: boolean
        default: false
      include_public_with_prerelease:
        description: 'Include repositories with public release + newer pre-release'
        required: false
        type: boolean
        default: false

concurrency:
  group: campaign-release-info-${{ github.ref }}
  cancel-in-progress: false

env:
  MODE: ${{ inputs.dry_run && 'plan' || 'apply' }}
  ORG: camaraproject
  RELEASES_FILE: data/releases-master.yaml
  INCLUDE: ${{ inputs.include }}
  INCLUDE_NO_RELEASE: ${{ inputs.include_no_release }}
  INCLUDE_PRERELEASE_ONLY: ${{ inputs.include_prerelease_only }}
  INCLUDE_PUBLIC_RELEASE: ${{ inputs.include_public_release }}
  INCLUDE_PUBLIC_WITH_PRERELEASE: ${{ inputs.include_public_with_prerelease }}
  BRANCH: bulk/release-info-sync-${{ github.run_id }}
  PR_TITLE: "[bulk] Sync Release Information section"
  PR_BODY: "Automated update of README Release Information section"

permissions:
  contents: write
  pull-requests: write

jobs:
  select:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.sel.outputs.repos }}
      mode: ${{ env.MODE }}
    steps:
      - name: Checkout admin repo (self)
        uses: actions/checkout@v6
        with:
          path: admin

      - name: Install js-yaml
        run: npm install js-yaml

      - id: sel
        name: Build repo list (from releases-master.yaml with category filtering)
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const doc = yaml.load(fs.readFileSync('admin/data/releases-master.yaml', 'utf8'));

            // Use repositories section for category-aware filtering
            // Filter out archived repos (PRs cannot be created on archived repos)
            const repos = (doc?.repositories || []).filter(r => !r.repository_archived);

            // Determine release state for each repo
            const categorized = repos.map(r => {
              const hasPublic = r.latest_public_release !== null;
              const hasPre = r.newest_pre_release !== null;
              let state;
              if (!hasPublic && !hasPre) state = 'no_release';
              else if (!hasPublic && hasPre) state = 'prerelease_only';
              else if (hasPublic && !hasPre) state = 'public_release';
              else state = 'public_with_prerelease';
              return { repo: r.repository, state };
            });

            // Filter by enabled categories
            const includeNoRelease = process.env.INCLUDE_NO_RELEASE === 'true';
            const includePreOnly = process.env.INCLUDE_PRERELEASE_ONLY === 'true';
            const includePublic = process.env.INCLUDE_PUBLIC_RELEASE === 'true';
            const includePublicPre = process.env.INCLUDE_PUBLIC_WITH_PRERELEASE === 'true';

            console.log(`Category filters: no_release=${includeNoRelease}, prerelease_only=${includePreOnly}, public_release=${includePublic}, public_with_prerelease=${includePublicPre}`);

            let list = categorized
              .filter(r => {
                if (r.state === 'no_release' && includeNoRelease) return true;
                if (r.state === 'prerelease_only' && includePreOnly) return true;
                if (r.state === 'public_release' && includePublic) return true;
                if (r.state === 'public_with_prerelease' && includePublicPre) return true;
                return false;
              })
              .map(r => `${process.env.ORG}/${r.repo}`);

            // Apply INCLUDE filter if set (further restrict to specific repos)
            const include = (process.env.INCLUDE||'').split(',').map(s=>s.trim()).filter(Boolean);
            if (include.length) list = list.filter(r => include.some(x => r.endsWith(`/${x}`)));

            console.log(`Selected ${list.length} repositories for processing`);
            core.setOutput('repos', JSON.stringify(list));

  run:
    needs: select
    if: ${{ fromJson(needs.select.outputs.repos)[0] != null }}
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ env.MODE }}
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.select.outputs.repos) }}

    steps:
      - name: Checkout admin repo (self)
        uses: actions/checkout@v6
        with:
          path: admin

      - name: Checkout target repo
        uses: actions/checkout@v6
        with:
          repository: ${{ matrix.repo }}
          path: repo
          fetch-depth: 0
          token: ${{ secrets.BULK_CAMPAIGN_TOKEN }}

      - name: Read release data
        id: data
        uses: ./admin/actions/read-release-data
        with:
          releases_file: ${{ github.workspace }}/admin/${{ env.RELEASES_FILE }}
          repo_slug: ${{ matrix.repo }}

      - name: Format API lines
        id: format
        uses: actions/github-script@v8
        with:
          script: |
            const data = JSON.parse(`${{ steps.data.outputs.json }}`);

            // Format public release APIs
            if (!data.apis || data.apis.length === 0) {
              core.info('No public release APIs found, using empty formatted_apis');
              data.formatted_apis = '';
            } else {
              const apiLines = data.apis.map(api => {
                return '  * **' + api.file_name + ' v' + api.version + '**\n' +
                  '  [[YAML]](https://github.com/camaraproject/' + data.repo_name + '/blob/' + data.latest_public_release + '/code/API_definitions/' + api.file_name + '.yaml)\n' +
                  '  [[ReDoc]](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/camaraproject/' + data.repo_name + '/' + data.latest_public_release + '/code/API_definitions/' + api.file_name + '.yaml&nocors)\n' +
                  '  [[Swagger]](https://camaraproject.github.io/swagger-ui/?url=https://raw.githubusercontent.com/camaraproject/' + data.repo_name + '/' + data.latest_public_release + '/code/API_definitions/' + api.file_name + '.yaml)';
              }).join('\n');
              data.formatted_apis = apiLines;
            }

            // Format pre-release APIs
            if (!data.prerelease_apis || data.prerelease_apis.length === 0) {
              core.info('No pre-release APIs found, using empty formatted_prerelease_apis');
              data.formatted_prerelease_apis = '';
            } else {
              const preApiLines = data.prerelease_apis.map(api => {
                return '  * **' + api.file_name + ' v' + api.version + '**\n' +
                  '  [[YAML]](https://github.com/camaraproject/' + data.repo_name + '/blob/' + data.newest_prerelease + '/code/API_definitions/' + api.file_name + '.yaml)\n' +
                  '  [[ReDoc]](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/camaraproject/' + data.repo_name + '/' + data.newest_prerelease + '/code/API_definitions/' + api.file_name + '.yaml&nocors)\n' +
                  '  [[Swagger]](https://camaraproject.github.io/swagger-ui/?url=https://raw.githubusercontent.com/camaraproject/' + data.repo_name + '/' + data.newest_prerelease + '/code/API_definitions/' + api.file_name + '.yaml)';
              }).join('\n');
              data.formatted_prerelease_apis = preApiLines;
            }

            core.setOutput('enhanced_json', JSON.stringify(data));

      - name: Ensure Release Info section delimiters
        id: ensure
        continue-on-error: true
        uses: ./admin/actions/ensure-delimited-section
        with:
          file: repo/README.md
          start: "<!-- CAMARA:RELEASE-INFO:START -->"
          end:   "<!-- CAMARA:RELEASE-INFO:END -->"
          placeholder: "_This section is managed by project-administration_"

      - name: Select template based on release state
        id: template
        if: steps.ensure.outcome == 'success'
        run: |
          STATE=$(echo '${{ steps.data.outputs.json }}' | jq -r '.release_state')
          case "$STATE" in
            no_release) TEMPLATE="release-info-no-release.mustache" ;;
            prerelease_only) TEMPLATE="release-info-prerelease-only.mustache" ;;
            public_release) TEMPLATE="release-info-public.mustache" ;;
            public_with_prerelease) TEMPLATE="release-info-public-with-prerelease.mustache" ;;
            *) TEMPLATE="release-info-public.mustache" ;;
          esac
          echo "template=$TEMPLATE" >> $GITHUB_OUTPUT
          echo "Selected template: $TEMPLATE for state: $STATE"

      - name: Render content template → /tmp/release-info.md
        id: render
        if: steps.ensure.outcome == 'success'
        uses: ./admin/actions/render-mustache
        with:
          template: ${{ github.workspace }}/admin/campaigns/release-info/templates/${{ steps.template.outputs.template }}
          data_json: ${{ steps.format.outputs.enhanced_json }}
          out_file: /tmp/release-info.md

      - name: Render PR body template → /tmp/pr-body.md
        id: render_pr_body
        if: steps.ensure.outcome == 'success'
        uses: ./admin/actions/render-mustache
        with:
          template: ${{ github.workspace }}/admin/campaigns/release-info/templates/pr-body.mustache
          data_json: ${{ steps.format.outputs.enhanced_json }}
          out_file: /tmp/pr-body.md

      - name: Replace delimited content (writes in-place)
        id: replace
        if: steps.ensure.outcome == 'success'
        uses: ./admin/actions/replace-delimited-content
        with:
          file: repo/README.md
          start: "<!-- CAMARA:RELEASE-INFO:START -->"
          end:   "<!-- CAMARA:RELEASE-INFO:END -->"
          new_content_file: /tmp/release-info.md

      - name: Detect changes with git diff
        id: diff
        if: steps.ensure.outcome == 'success'
        uses: actions/github-script@v8
        with:
          script: |
            const { execSync } = require('child_process');
            const branch = process.env.BRANCH;
            let changed = 'false';

            try {
              // Check if remote branch exists
              execSync(`git fetch origin ${branch}`, { cwd: 'repo', stdio: 'pipe' });
              const remoteBranchExists = execSync(`git rev-parse --verify origin/${branch}`, { cwd: 'repo', stdio: 'pipe' }).toString().trim();

              if (remoteBranchExists) {
                // Compare against remote PR branch
                console.log(`Comparing against existing remote branch origin/${branch}`);
                try {
                  execSync(`git diff --quiet origin/${branch} -- README.md`, { cwd: 'repo' });
                  console.log('No changes detected compared to PR branch');
                } catch {
                  changed = 'true';
                  console.log('Changes detected compared to PR branch');
                }
              } else {
                // Compare against main (no PR branch exists)
                console.log('No remote branch exists, comparing against main');
                try {
                  execSync('git diff --quiet', { cwd: 'repo' });
                } catch {
                  changed = 'true';
                  console.log('Changes detected compared to main');
                }
              }
            } catch (err) {
              // Remote branch doesn't exist or fetch failed, compare against main
              console.log('Remote branch not found, comparing against main');
              try {
                execSync('git diff --quiet', { cwd: 'repo' });
              } catch {
                changed = 'true';
              }
            }

            core.setOutput('changed', changed);

      - name: Capture error state
        id: error
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const ensureOutcome = '${{ steps.ensure.outcome }}';

            if (ensureOutcome === 'failure') {
              core.setOutput('error_occurred', 'true');
              core.setOutput('error_message', 'Release Information section markers not found in README.md');
              core.setOutput('error_step', 'ensure-delimiters');
            } else {
              core.setOutput('error_occurred', 'false');
              core.setOutput('error_message', '');
              core.setOutput('error_step', '');
            }

      - name: Finalize campaign per repo
        if: always()
        uses: ./admin/actions/campaign-finalize-per-repo
        with:
          mode: ${{ env.MODE }}
          changed: ${{ steps.diff.outputs.changed || 'false' }}
          repo: ${{ matrix.repo }}
          campaign_data: ${{ steps.data.outputs.summary }}
          pr_base_title: ${{ env.PR_TITLE }}
          pr_body_file: /tmp/pr-body.md
          branch: ${{ env.BRANCH }}
          github_token: ${{ secrets.BULK_CAMPAIGN_TOKEN }}
          error_occurred: ${{ steps.error.outputs.error_occurred }}
          error_message: ${{ steps.error.outputs.error_message }}
          error_step: ${{ steps.error.outputs.error_step }}

  aggregate:
    needs: [select, run]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Determine artifact pattern
        id: pattern
        run: |
          MODE="${{ needs.select.outputs.mode }}"
          if [ "$MODE" = "plan" ]; then
            echo "pattern=plan-*" >> $GITHUB_OUTPUT
            echo "output_name=plan" >> $GITHUB_OUTPUT
            echo "dir_name=plans" >> $GITHUB_OUTPUT
          else
            echo "pattern=results-*" >> $GITHUB_OUTPUT
            echo "output_name=results" >> $GITHUB_OUTPUT
            echo "dir_name=results" >> $GITHUB_OUTPUT
          fi

      - uses: actions/download-artifact@v7
        with:
          pattern: ${{ steps.pattern.outputs.pattern }}
          path: ${{ steps.pattern.outputs.dir_name }}

      - name: Merge artifacts
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const p = '${{ steps.pattern.outputs.dir_name }}';
            const outputName = '${{ steps.pattern.outputs.output_name }}';

            if (!fs.existsSync(p)) {
              console.log(`No ${p} directory found, no artifacts were downloaded`);
              fs.writeFileSync(`${outputName}.md`, `# No ${outputName} artifacts found\n`);
              fs.writeFileSync(`${outputName}.jsonl`, '');
              return;
            }
            const md = []; const lines = [];
            const entries = fs.readdirSync(p);
            if (entries.length === 0) {
              console.log(`${p} directory is empty, no artifacts were downloaded`);
              fs.writeFileSync(`${outputName}.md`, `# No ${outputName} artifacts found\n`);
              fs.writeFileSync(`${outputName}.jsonl`, '');
              return;
            }
            // Handle both artifact layouts (#125):
            // - Multiple artifacts: p/plan-xxx-0/plan.md (subdirectories)
            // - Single artifact (download-artifact v5+): p/plan.md (flat)
            for (const entry of entries) {
              const entryPath = `${p}/${entry}`;
              const stat = fs.statSync(entryPath);
              if (stat.isDirectory()) {
                if (fs.existsSync(`${entryPath}/${outputName}.md`))    md.push(fs.readFileSync(`${entryPath}/${outputName}.md`,'utf8'));
                if (fs.existsSync(`${entryPath}/${outputName}.jsonl`)) lines.push(fs.readFileSync(`${entryPath}/${outputName}.jsonl`,'utf8'));
              } else if (entry === `${outputName}.md`) {
                md.push(fs.readFileSync(entryPath, 'utf8'));
              } else if (entry === `${outputName}.jsonl`) {
                lines.push(fs.readFileSync(entryPath, 'utf8'));
              }
            }
            fs.writeFileSync(`${outputName}.md`, md.join('\n'));
            fs.writeFileSync(`${outputName}.jsonl`, lines.join(''));
      - uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.pattern.outputs.output_name }}
          path: |
            ${{ steps.pattern.outputs.output_name }}.md
            ${{ steps.pattern.outputs.output_name }}.jsonl
      - name: Summary
        run: |
          OUTPUT_NAME="${{ steps.pattern.outputs.output_name }}"
          MODE_TITLE=$(echo "$OUTPUT_NAME" | sed 's/.*/\u&/')
          echo "## ${MODE_TITLE} overview" >> $GITHUB_STEP_SUMMARY
          echo "- JSONL lines: $(wc -l < ${OUTPUT_NAME}.jsonl)" >> $GITHUB_STEP_SUMMARY
