# =========================================================================================
# CAMARA Project - Action: Campaign Finalize Per Repo
#
# Generic finalization for PR-based campaign workflows. Handles commit, push,
# PR creation, duplicate detection, and artifact upload.
#
# CHANGELOG:
# - 2026-01-27: Added standardized header for r1.3 release
# =========================================================================================
name: 'Campaign Finalize Per Repo'
description: 'Generic finalization for campaign workflows: commit, PR, record, upload'
inputs:
  mode:
    description: 'Workflow mode (plan or apply)'
    required: true
  changed:
    description: 'Whether changes were detected'
    required: true
  repo:
    description: 'Repository name (org/repo)'
    required: true
  campaign_data:
    description: 'JSON with campaign-specific data'
    required: false
    default: '{}'
  pr_base_title:
    description: 'Base PR title (date suffix added automatically)'
    required: false
    default: ''
  pr_body_file:
    description: 'Path to rendered PR body file (apply mode only)'
    required: false
    default: ''
  branch:
    description: 'Branch name for PR'
    required: false
    default: ''
  github_token:
    description: 'GitHub token for PR creation (apply mode only)'
    required: false
    default: ''
  error_occurred:
    description: 'Whether an error occurred during workflow execution'
    required: false
    default: 'false'
  error_message:
    description: 'Error message if error occurred'
    required: false
    default: ''
  error_step:
    description: 'Step where error occurred'
    required: false
    default: ''
  target_files:
    description: 'Files to track for changes and commit (space-separated)'
    required: false
    default: 'README.md'
  label_name:
    description: 'GitHub label for campaign PRs'
    required: false
    default: 'automated'
  label_color:
    description: 'Label color (hex without #)'
    required: false
    default: 'd1d5db'
  label_description:
    description: 'Label description'
    required: false
    default: 'Automated bulk operations from project-administration'

runs:
  using: 'composite'
  steps:
    - name: Detect existing PR
      id: detect
      if: ${{ inputs.error_occurred != 'true' }}
      shell: bash
      working-directory: repo
      run: |
        # Search for PRs by base title (partial match) and campaign label, sort by created_at DESC
        PR_DATA=$(gh pr list \
          --search "in:title \"${{ inputs.pr_base_title }}\" label:${{ inputs.label_name }}" \
          --json number,url,title,createdAt,headRefName \
          --jq 'sort_by(.createdAt) | reverse | .[0]' 2>/dev/null || echo "{}")

        PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number // empty')
        PR_URL=$(echo "$PR_DATA" | jq -r '.url // empty')
        PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName // empty')
        PR_TITLE=$(echo "$PR_DATA" | jq -r '.title // empty')

        if [ -n "$PR_NUMBER" ]; then
          echo "pr_exists=true" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "pr_branch=$PR_BRANCH" >> $GITHUB_OUTPUT
          echo "Detected newest PR #$PR_NUMBER: $PR_URL"
          echo "  Title: $PR_TITLE"
          echo "  Branch: $PR_BRANCH"
        else
          echo "pr_exists=false" >> $GITHUB_OUTPUT
          echo "pr_number=" >> $GITHUB_OUTPUT
          echo "pr_url=" >> $GITHUB_OUTPUT
          echo "pr_branch=" >> $GITHUB_OUTPUT
          echo "No existing PR found (searched by base title and label)"
        fi
      env:
        GH_TOKEN: ${{ inputs.github_token }}

    - name: Change detection
      id: change_check
      if: ${{ inputs.error_occurred != 'true' }}
      shell: bash
      working-directory: repo
      run: |
        # If PR already exists, skip (no superseding)
        if [ "${{ steps.detect.outputs.pr_exists }}" = "true" ]; then
          echo "Existing PR found (#${{ steps.detect.outputs.pr_number }}) → skip"
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "reason=existing_pr" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Compare against main (stage files first to detect new files)
        git add ${{ inputs.target_files }} 2>/dev/null || true
        if git diff --cached --quiet -- ${{ inputs.target_files }}; then
          echo "No changes vs main → noop"
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "reason=main_up_to_date" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Changes detected, will create PR"
        echo "changed=true" >> $GITHUB_OUTPUT
        echo "reason=new_changes" >> $GITHUB_OUTPUT

    - name: Generate PR title with date
      id: pr_title
      if: ${{ inputs.error_occurred != 'true' }}
      shell: bash
      working-directory: repo
      run: |
        DATE=$(date -u +%Y-%m-%d)
        BASE_TITLE="${{ inputs.pr_base_title }}"

        # Search for PRs with same date in title
        EXISTING_TITLES=$(gh pr list \
          --search "in:title \"$BASE_TITLE ($DATE\" label:${{ inputs.label_name }}" \
          --json title \
          --jq '.[].title' 2>/dev/null || echo "")

        # Find highest number for today (format: YYYY-MM-DD-NNN)
        MAX_NUM=0
        if [ -n "$EXISTING_TITLES" ]; then
          while IFS= read -r title; do
            # Extract number from format like "[bulk] Title (2025-10-28-002)"
            if [[ "$title" =~ \($DATE-([0-9]+)\) ]]; then
              NUM="${BASH_REMATCH[1]}"
              NUM=$((10#$NUM))  # Remove leading zeros
              if [ "$NUM" -gt "$MAX_NUM" ]; then
                MAX_NUM=$NUM
              fi
            fi
          done <<< "$EXISTING_TITLES"
        fi

        # Increment and format
        NEXT_NUM=$((MAX_NUM + 1))
        NUM_STR=$(printf "%03d" $NEXT_NUM)
        PR_TITLE="$BASE_TITLE ($DATE-$NUM_STR)"

        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
        echo "Generated PR title: $PR_TITLE"
      env:
        GH_TOKEN: ${{ inputs.github_token }}

    - name: Determine PR status
      id: pr_status
      if: ${{ inputs.error_occurred != 'true' }}
      shell: bash
      run: |
        CHANGED="${{ steps.change_check.outputs.changed }}"

        if [ "$CHANGED" = "true" ]; then
          STATUS="will_create"
        else
          STATUS="no_change"
        fi

        echo "pr_status=$STATUS" >> $GITHUB_OUTPUT
        echo "Determined PR status: $STATUS (reason: ${{ steps.change_check.outputs.reason }})"

    - name: APPLY - Ensure campaign label exists
      if: ${{ inputs.mode == 'apply' && steps.change_check.outputs.changed == 'true' }}
      shell: bash
      working-directory: repo
      run: |
        # Check if campaign label exists, create if not
        if ! gh label list --json name --jq '.[].name' | grep -q "^${{ inputs.label_name }}$"; then
          echo "Creating '${{ inputs.label_name }}' label..."
          gh label create "${{ inputs.label_name }}" \
            --description "${{ inputs.label_description }}" \
            --color "${{ inputs.label_color }}"
          echo "Label created"
        else
          echo "Label '${{ inputs.label_name }}' already exists"
        fi
      env:
        GH_TOKEN: ${{ inputs.github_token }}

    - name: APPLY - Commit to branch
      id: commit
      if: ${{ inputs.mode == 'apply' && steps.change_check.outputs.changed == 'true' }}
      shell: bash
      working-directory: repo
      run: |
        # Derive git user from token identity
        if ! TOKEN_INFO=$(gh api user --jq '{login: .login, id: .id}' 2>&1); then
          echo "::error::Failed to get token identity: $TOKEN_INFO"
          exit 1
        fi
        TOKEN_USER=$(echo "$TOKEN_INFO" | jq -r '.login')
        TOKEN_ID=$(echo "$TOKEN_INFO" | jq -r '.id')
        if [ -z "$TOKEN_USER" ] || [ "$TOKEN_USER" = "null" ]; then
          echo "::error::Could not determine token user identity"
          exit 1
        fi
        GIT_USER_NAME="${TOKEN_USER}"
        GIT_USER_EMAIL="${TOKEN_ID}+${TOKEN_USER}@users.noreply.github.com"
        echo "Committing as: $GIT_USER_NAME <$GIT_USER_EMAIL>"
        git config user.name "$GIT_USER_NAME"
        git config user.email "$GIT_USER_EMAIL"
        git checkout -B "${{ inputs.branch }}"
        for f in ${{ inputs.target_files }}; do
          if [ -e "$f" ]; then
            git add "$f"
          else
            git rm -f --ignore-unmatch "$f"
          fi
        done
        git commit -m "${{ steps.pr_title.outputs.pr_title }}" || echo "No changes to commit"
        git push origin "${{ inputs.branch }}"
        echo "push_succeeded=true" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ inputs.github_token }}

    - name: APPLY - Create PR
      id: pr_create
      if: ${{ inputs.mode == 'apply' && steps.change_check.outputs.changed == 'true' }}
      shell: bash
      working-directory: repo
      run: |
        echo "Creating new PR..."
        PR_URL=$(gh pr create \
          --title "${{ steps.pr_title.outputs.pr_title }}" \
          --body-file "${{ inputs.pr_body_file }}" \
          --head "${{ inputs.branch }}" \
          --base main \
          --label "${{ inputs.label_name }}")
        echo "created_pr_url=$PR_URL" >> $GITHUB_OUTPUT
        echo "Created PR: $PR_URL"
      env:
        GH_TOKEN: ${{ inputs.github_token }}

    - name: Record outcome
      if: always()
      shell: bash
      run: |
        node ${{ github.action_path }}/dist/index.js
      env:
        INPUT_REPO: ${{ inputs.repo }}
        INPUT_CHANGED: ${{ inputs.changed }}
        INPUT_MODE: ${{ inputs.mode }}
        INPUT_CAMPAIGN_DATA: ${{ inputs.campaign_data }}
        INPUT_PR_STATUS: ${{ steps.pr_status.outputs.pr_status }}
        INPUT_PR_NUMBER: ${{ steps.detect.outputs.pr_number }}
        INPUT_PR_URL: ${{ steps.pr_create.outputs.created_pr_url || steps.detect.outputs.pr_url }}
        INPUT_CHANGE_REASON: ${{ steps.change_check.outputs.reason }}
        INPUT_ERROR_OCCURRED: ${{ inputs.error_occurred }}
        INPUT_ERROR_MESSAGE: ${{ inputs.error_message }}
        INPUT_ERROR_STEP: ${{ inputs.error_step }}

    - name: Copy generated files for plan artifact
      if: ${{ inputs.mode == 'plan' }}
      shell: bash
      run: |
        # Copy generated target files to plan artifact directory
        mkdir -p plan-files
        for file in ${{ inputs.target_files }}; do
          if [ -f "repo/$file" ]; then
            cp "repo/$file" "plan-files/"
          fi
        done

    - name: Reset repo (plan mode)
      if: ${{ inputs.mode == 'plan' }}
      shell: bash
      working-directory: repo
      run: |
        git reset --hard
        git clean -fd

    - name: Upload artifacts
      uses: actions/upload-artifact@v6
      with:
        name: ${{ inputs.mode == 'plan' && format('plan-{0}-{1}', github.run_id, strategy.job-index) || format('results-{0}-{1}', github.run_id, strategy.job-index) }}
        path: |
          ${{ inputs.mode == 'plan' && 'plan' || 'results' }}.md
          ${{ inputs.mode == 'plan' && 'plan' || 'results' }}.jsonl
          ${{ inputs.mode == 'plan' && 'plan-files/*' || '' }}
